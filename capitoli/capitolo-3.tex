% !TEX encoding = UTF-8
% !TEX TS-program = pdflatex
% !TEX root = ../tesi.tex
%**************************************************************
\chapter{Archittetura del sistema AWMS}
\label{cap:archittettura del sistema AWMS}
%**************************************************************

\intro{In questo capitolo verranno descritti tutte le componenti dell'architettura \gls{AWMS} e le varie operazioni di comunicazione tra le varie componenti.}\\


\section{Descrizione}
Come scritto precedentemente, dietro all'applicazione mobile c'è tutta un'architettura di sistema che permette la comunicazione tra la piattaforma \gls{AWMS} e l'applicazione mobile con Azzurra.
 
 \begin{figure}[h]
 	\begin{center}
 		\includegraphics[scale=0.28]{AWMSDiagram.png}
 		\caption{Architettura di sistema AWMS}\label{fig:arch}
 	\end{center}
 \end{figure}
La figura precedente illustra come è composta l'architettura, dove ogni componente verrà descritta nelle successive sotto sezioni.
\begin{trivlist}
	\item \subsection{AWMS Dashboard}
	È il pannello di controllo attraverso il quale un project manager può interagire con la piattaforma \gls{AWMS} per poter pianificare il lavoro da svolgere, cioè assegnare un compito alla persona più idonea. Il pannello di controllo è una applicazione web che è stata sviluppata in Angular.
	\begin{figure}[h] 
		\begin{center}
			\includegraphics[height=8cm,width=13cm]{dashboardAWMS.png}
			\caption{Schermata di AWMS Dashboard}
		\end{center}
	\end{figure}
	 	La dashboard per comunicare con il back-end, utilizza delle \gls{api}\ap{[g]} che il back-end espone, quindi per una ragione di sicurezza, back-end e l'applicazione web cioè il front-end, comunicano attraverso \gls{api}\ap{[g]} con in più l'utilizzo del protocollo di comunicazione HTTPS che cripta la comunicazione. Nella Figura~\ref{fig:arch} viene mostrato il caso in cui il front-end utilizza \gls{api}\ap{[g]} per l'invio di notifiche push, questo perché è previsto che una volta il team leader sceglie il lavoratore più idoneo per un certo lavoro, il lavoratore deve essere avvisato, cosi sarà compito del front-end avvisare il back-end che c'è stata una nuova assegnazione e che questa assegnazione deve essere comunicata al diretto interessato attraverso un notifica sull'applicazione mobile con all'interno Azzurra.
	\item \subsection{AWMS backend}
	Come dice il suo nome, AWMS Backend rappresenta il backend del sistema. AWMS Backend è sviluppato usando lo strumento CakePHP, un framework per lo sviluppo di applicazioni web scritto in PHP. Al suo interno risiede il database che contiene tutte le informazioni sui lavoratori e tra questi quindi, i dati da mostrare nei messaggi di Azzurra come ad esempio il piano di lavoro che ha il lavoratore in uno specifico giorno, qualora ne venga fatta richiesta. Il database utilizza come DBMS PostgreSQL. \\
	Come detto al punto precedente, per comunicare con il backend, esso espone delle \gls{api}\ap{[g]} per la comunicazione infatti, esiste un \gls{api}\ap{[g]} per l'invio di notifiche push ma esiste anche un \gls{api}\ap{[g]}, utilizzata da Azzurra.io, per la richiesta di informazioni sul lavoratore necessarie per completare il flusso di conversazione. Quindi questa \gls{api}\ap{[g]} permetterà di richiedere dati al backend che li andrà a cercare nel suo database interno che se l'interrogazione al database da esito positivo, ritornerà le informazioni richieste a Azzurra.io. Il backend si trova all'interno della rete interna dell'azienda che ha acquistato la soluzione di AzzurroDigitale, anche Azzurra.io è all'interno della rete, perciò tra queste due componenti avviene attraverso il protocollo di comunicazione HTTP. Il backend ha la possibilità di comunicare direttamente con Azzurra.io quando deve inviare una notifica push e ha necessità di sapere quali utenti sono attivi, cioè hanno una connessione aperta con Azzurra.io. Per gli utenti invece che non hanno una connessione aperte con Azzurra.io e quindi non sono attivi l'invio della notifica verrà fatto utilizzando i servizi offerti da Firebase, la cui comunicazione tra backend e Firebase avviene tramite HTTPS perché Firebase è un servizio esterno.\\
	La gestione l'invio delle notifiche push verrà comunque tratta in modo più dettagliato più avanti nel seguente capitolo.
	\item \subsection{Azzurra.io}
	Azzurra.io è una componente strategica per il funzionamento del \gls{bot}\ap{[g]} Azzurra. Azzurra.io è sviluppata attraverso il framework NestJS. Al suo interno ha due database con DBMS PostgreSQL. Il primo database contiene i flussi di conversazione che indicano al \gls{bot}\ap{[g]} la sequenza di passi che deve seguire durante la conversazione con l'utente umano, la struttura dei flussi conversazionali verrà spiegata in modo dettagliato al capitolo successivo. Il secondo database permette di memorizzare i messaggi fatti tra il \gls{bot}\ap{[g]} Azzurra e l'utente umano. La scelta di adottare quest'ultimo database è dettata dalle seguenti motivazioni:
	\begin{itemize}
		\item Per mantenere lo stato della conversazione cioè, se l'utente decide di non andare avanti con la conversazione e di continuarla in un secondo momento, grazie a questo database, in cui viene salvato lo stato della conversazione, l'utente potrà continuare la conversazione da dove l'aveva lasciata. Il mantenimento dello stato della conversazione non avviene per un tempo illimitato ma dura al massimo un'ora dopo di che lo stato verrà cancellato;
		\item Per una migliore \emph{user experience} si è scelto, nel caso in cui ci siano state delle conversazioni in precedenza, di mostrare i messaggi delle conversazioni precedenti, cosi che se l'utente ha bisogno di un’informazione che ha già chiesto precedentemente ma che si è dimenticato, basta che controlli i messaggi presenti nella \emph{chat} senza dover richiedere ad Azzurra l'informazione dimenticata.
	\end{itemize}
	La connessione tra l'applicazione mobile e Azzurra.io è possibile grazie ai \gls{WebSocket}\ap{[g]} che permettono di aprire una connessione tra i due e di mantenere sempre aggiornati i dati ad esempio la struttura dei flussi di conversazione, qualora venissero aggiornati. Per tenere traccia degli utenti connessi con Azzurra.io tramite l'applicazione mobile, viene utilizzata la mappa chiave-valore, interna ad Azzurra.io, denominata User Map. Grazie a essa permetterà di rispondere alle richieste del backend quando avrà bisogno della lista di utenti attivi per l'invio della notifica push. Come detto all'inizio del punto Azzurro.io è un componente strategico per principalmente due motivi.
	\begin{itemize}
		\item Quando si vuole aggiungere un nuovo flusso conversazionale o modificare un flusso già esistente, se non esistesse Azzurra.io, questi sarebbero salvati nell'applicazione che ne comporterebbe l'aggiornamento dell'applicazione mobile e quindi effettuare una nuova pubblicazione nell'Play Store per i dispositivi Android e nel Apple Store per i dispositivi iOS ad ogni aggiunta o modifica dei flussi. Grazie all'esistenza di Azzurra.io ciò viene evitato perché esiste il database dedicato per la memorizzazione dei flussi conversazionali che permette di aggiungere un nuovo flusso, semplicemente inserendolo all'interno del database, analogamente per la modifica di un flusso. Inoltre, grazie alla connessione tramite \gls{WebSocket}\ap{[g]} qualunque modifica o aggiunta viene subito recepita dell'applicazione mobile;
		\item Per evitare che vengano fatte un numero elevato di richieste al backend si è deciso di distribuire le informazioni in diverse componenti della rete, infatti il \gls{bot}\ap{[g]} per sapere che flusso conversazionale deve seguire per genere i messaggi per la conversazione con l'utente umano, chiede a Azzurra.io e non al backend. Il backend però verrà contattato quando il \gls{bot}\ap{[g]} Azzurra ha bisogno di dati sul lavoratore da mostrare, questa richiesta però sarà fatta inizialmente a Azzurra.io che si prenderà carico di richiedere le informazioni al backend e di ritornarle all'applicazione. Quindi il backend sarà contattato solo dalla dashboard e da Azzurra.io per il caso descritto precedentemente o per il processo di autenticazione dell'utente, diminuendo il carico sul backend.
	\end{itemize}
	
	\item\subsection{Applicazione mobile}
	L'ultimo componente dell'architettura e l'applicazione mobile. Essa è sviluppata attraverso il framework Angular2+ e Ionic e al suo interno risiede il \gls{bot}\ap{[g]} Azzurra. Oltre al \gls{bot}\ap{[g]} Azzurra esisto altre due sezioni, la sezione questionario e la sezione profilo. 
	
	\begin{figure}[h]
		\centering
		\includegraphics[scale=0.15]{queGrey.png}\hfill
		\includegraphics[scale=0.15]{queGreen.png}\hfill
		\includegraphics[scale=0.15]{queRed.png}
		\caption{Sezione Questionario}\label{fig:que}
	\end{figure}
	
	La Figura~\ref{fig:que} mostra la sezione Questionario nei suoi 3 possibili stati. In questa sezione viene richiesto di compilare quotidianamente un questionario in cui vengono poste domande sulla propria salute che, dai dati raccolti per ogni lavoratore l'applicazione cerca di capire se all'interno dell'azienda ci sia pericolo di contagio del virus COVID-19. Nel caso in cui non si è ancora compilato il questionario, viene mostrata una faccina grigia come si può vedere nella prima immagine della Figura~\ref{fig:que}. Se si è compilato il questionario e secondo le risposte date si risulta essere in buona salute, allora l'applicazione mostrerà una faccina verde come si può vedere nella seconda immagine della Figura~\ref{fig:que}. Se si è compilato il questionario e secondo le risposte date si risulta essere a rischio con la propria salute, allora l'applicazione mostrerà una faccina rossa come si può vedere dalla terza immagine della Figura~\ref{fig:que}.
	\\
	\clearpage
	In questa sezione viene richiesto di compilare un questionario dove vengono richiesti se si hanno avuto dei sintomi di malattie come mostra la prima immagine della Figura~\ref{fig:queSlide}. Successivamente viene richiesto se le persone vicino a noi hanno avuto qualche sintomo di malattie come mostrato nella seconda immagine della Figura~\ref{fig:queSlide}. Viene poi richiesto in quelli luoghi si è stati come mostrato nella seconda immagine della Figura~\ref{fig:queSlide}.
	\begin{figure}[h]
		\begin{center}
			\includegraphics[scale=0.125]{que1.png}\hfill
			\includegraphics[scale=0.125]{que2.png}\hfill
			\includegraphics[scale=0.125]{que3.png}
			\caption{Schede del questionario sulla salute}\label{fig:queSlide}
		\end{center}
	\end{figure}

	Una volta terminato il questionario, l'applicazione elaborare le risposte date e mostrerà l'esito sulla nostra salute. Nel caso in cui l'esito sia positivo verrà mostrata la prima immagine della Figura~\ref{fig:quefinal} invece in caso di esito negativo verrà mostrata la seconda immagine della Figura~\ref{fig:quefinal}.
	\begin{figure}[h]
		\begin{center}
			\includegraphics[scale=0.125]{finalGreen.png}\hfil
			\includegraphics[scale=0.125]{finalRed.png}
			\caption{Schede dell'esito del questionario sulla salute}\label{fig:quefinal}
		\end{center}
	\end{figure}\\
	Il risultato viene poi riportato anche nella schermata della sezione Questionario.
	\\
	Nella sezione Profilo invece, vengono mostrati i Karma points che sono stati raccolti durante la compilazione del questionario, punti che al momento non danno nessun particolare beneficio ma, in futuro è previsto l'implementazione di una qualche ricompensa. Vengono mostrate le proprie informazioni personali cliccando il tasto Informazioni personali come mostrato in Figura~\ref{fig:profile}, e possibile cambiare la password d'accesso cliccando il bottone Gestione password. Cliccando il bottone Istruzione di utilizzo mostrato sempre nella Figura~\ref{fig:profile} e possibile accedere a una breve guida su come utilizzare l'applicazione. Nel bottone Normativa privacy è possibile visionare la normativa sulla tutela della privacy GDPR mentre nel bottone Titolare trattamento viene indicato da chi vengono trattati i dati inseriti.
	\begin{figure}[h]
		\begin{center}
			\includegraphics[scale=0.15]{profile.png}\hfil
			\includegraphics[scale=0.15]{chatAzzurra.png}
			\caption{Sezione Profilo e Chat con Azzurra}\label{fig:profile}
		\end{center}
	\end{figure}\\
	Nella sezione Azzurra, è presente la chat \gls{bot}\ap{[g]} con Azzurra che attraverso il proprio flow engine, riesce a comprendere i flussi conversazionali ricevuti in input da Azzurra. Grazie a ciò il \gls{bot}\ap{[g]} Azzurra sa quali risposte e domande fare all'utente umano. Nel capitolo successivo verrà spiegato in modo dettagliato il funzionamento del Flow engine di Azzurra. Come detto precedentemente la comunicazione con Azzurra avviene attraverso \gls{WebSocket}\ap{[g]} che permette di tenere aggiornati i flussi conversazionali ricevuti da Azzurra nel caso in cui subiscano modifiche.	
	
\end{trivlist}
\section{Operazioni}
Nella seguente sezione verranno descritte le principali operazioni tra le varie componenti dell'architettura.
\subsection{Creazione di una connessione attreverso WebSocket}
Come spiegato in precedenza, la comunicazione tra l'applicazione mobile e Azzurra.io avviene attraverso l'utilizzo di \gls{WebSocket}\ap{[g]}. Grazie a ciò si ha un canale di comunicazione a due vie cioè, sia l'applicazione mobile e sia Azzurra.io possono inviare dati o richieste, le modifiche ai flussi conversazionali già esistenti o l'aggiunta di nuovi flussi, verranno comunicate all'applicazione mobile in tempo reale, aggiornando perciò i dati posseduti dell'applicazione. Infine, utilizzando una connessione tramite \gls{WebSocket}\ap{[g]}, risulta essere più efficiente e performante rispetto al \gls{pooling}\ap{[g]} perché il server non viene continuamente contatto da inutili richieste.
\begin{figure}[h]
	\begin{center}
		\includegraphics[scale=0.8]{Connection-WebSocket.PNG}
		\caption{Sequence diagram per la creazione di una connessione attraverso WebSocket}\label{fig:websocket}
	\end{center}
\end{figure}

Nella Figura~\ref{fig:websocket} viene mostrato come avviene la creazione di una connessione tra l'applicazione mobile e Azzurra, i passi perciò sono:
\begin{enumerate}
	\item All'inizio, l'applicazione mobile viene aperta dall'utente, essa cercherà da subito di mettersi in contatto con Azzurra.io creando una connessione;
	\item Per avviare una connessione \gls{WebSocket}\ap{[g]}, viene inviata una richiesta HTTP a Azzurra.io(server). Tale richiesta HTTP ha la particolarità che negli \emph{headers} dell’intestazione viene specificata un'operazione di tipo Upgrade che indica che l'applicazione mobile (client) vuole aggiornare la connessione ad un protocollo diverso, in questo caso a \gls{WebSocket}\ap{[g]}. Questo tipo di operazione prende il nome di \emph{WebSocket handshake request}.\\
	\begin{lstlisting}
GET /mychat HTTP/1.1
Host: server.AzzurraIo.com
Upgrade: websocket	
Connection: Upgrade		
Sec-WebSocket-Key: 32ndfsMjnQiZXBijAfOiPni==
Sec-WebSocket-Protocol: chat		
Sec-WebSocket-Version: 13		
Origin: http://AzzurraIo.com
	\end{lstlisting}
	Il codice soprastante rappresenta un esempio di \emph{WebSocket handshake request} inviata dal client al server. Il client inserisce una stringa casuale codifica in base64 nel campo \emph{Sec-WebSocket-Key} alla quelle viene poi aggiunta una stringa fissa.
	\item Se il server, in questo caso Azzurra.io supporta la connessione tramite \gls{WebSocket}\ap{[g]} allora rispondere mettendo nel campo \emph{Sec-WebSocket-Accept} la risposta cioè, l'hash della stringa contenuta in \emph{Sec-WebSocket-Key} utilizzando la funzione di hashing SHA-1. Infine, viene tutto codificato in base64. Una volta arrivata la risposta al client, esso controllerà se la risposta contiene la stringa corretta. Tutte queste operazioni hanno lo scopo di evitare di aprire più connessioni multiple ma non da nessuna garanzia di autenticazione.
	Nel seguente codice viene riportato un esempio di risposta da parte del server.\\
	\begin{lstlisting}
HTTP/1.1 101 Switching Protocols
Upgrade: websocket
Connection: Upgrade
Sec-WebSocket-Accept: fPmrc0slUIUYIuyY2HaGWk=
Sec-WebSocket-Protocol: chat
	\end{lstlisting}
\end{enumerate}
Per garantire una comunicazione sicura contro ascoltatori terzi viene usata una variante del \gls{WebSocket}\ap{[g]} detta Secure WebSocket (WSS) che utilizza il protocollo HTTPS al posto del protocollo HTTP
\subsection{Recupero di un flusso conversazionale}
\begin{figure}[h]
	\begin{center}
		\includegraphics[scale=0.75]{recovery.png}
		\caption{Sequence diagram per il recupero di un flusso conversazionale}\label{fig:recovery}
	\end{center}
\end{figure}
Il \gls{bot}\ap{[g]} Azzurra per poter funzionare ha bisogno di almeno un flusso conversazionale che grazie alla propria struttura, permette al flow engine di Azzurra di comprendere il flusso e capire quali messaggi deve far visualizzare ad Azzurra nella \emph{chat} con l'utente umano. I flussi si trovano nel database dedicato di Azzurra.io. Quando viene richiesto di fare un’operazione o si inizia per la prima volta un'interazione con Azzurra, essa per sapere cosa fare ha bisogno di uno specifico flusso di conversazione, nel caso in cui sia la prima interazione con l'utente, richiedere il cosiddetto \emph{MainFlow} dove vengono riportate quali funzionalità Azzurra può offrire. Se invece si è nel caso in cui l'utente richiede una specifica funzionalità ad esempio richiedere la visualizzazione del piano di lavoro, Azzurra dovrà richiedere il \emph{flow} dedicato alla specifica funzionalità.
Come mostrato nella Figura~\ref{fig:recovery} si hanno i seguenti passi:
\begin{enumerate}
\item L'utente interagisce con il \gls{bot}\ap{[g]} Azzurra e richiede una funzionalità oppure l'utente interagisce con Azzurra per la prima volta;
\item Il \gls{bot}\ap{[g]} Azzurra tramite una connessione aperta precedentemente chiede a Azzurra.io il corretto \emph{flow} per poter soddisfare le richieste dell'utente. Si sottolinea che ogni \emph{flow} ha un codice identificativo che lo identifica e Azzurra sa sempre qual'è il codice identificativo del flusso di cui ha bisogno;
\item Azzurra.io cerca nel proprio database se contiene il \emph{flow} richiesto;
\item Se la ricerca da esito positivo allora Azzurra.io ritornerà il flusso che verrà eseguito dal flow engine di Azzurra la quale proseguirà con la conversazione. Se invece non lo trova la conversazione si interrompe mostrando nella \emph{chat} un messaggio di errore.
\end{enumerate}

\subsection{Richiesta e invio di dati}
Durante l'esecuzione di una conversazione è molto probabile che Azzurra abbia bisogno di far visualizzare delle informazioni richieste dall'utente ad esempio il suo orario di lavoro, queste informazioni però non sono salvate ne nell'applicazione mobile né in Azzurra.io ma nel backend.
\begin{figure}[h]
	\begin{center}
		\includegraphics[height=5cm, width=13cm]{request.png}
		\caption{Sequence diagram per il recupero dei dati sul lavoratore}\label{fig:request}
	\end{center}
\end{figure}
La Figura~\ref{fig:request} mostra come Azzurra ottiene i dati richiesti:
\begin{enumerate}
	\item L'utente chiede una qualche operazione ad Azzurra che necessita contattare il backend per ottenere i dati che l'utente vuole;
	\item L'applicazione chiede quindi i dati necessari a Azzurra.io che si prende carico della richiesta;
	\item Azzurra.io contatta attraverso una richiesta HTTP, per richiedere i dati richiesti da Azzurra;
	\item Se la richiesta va a buon fine il backend ritornerà i dati ad Azzurra.io che li ritornerà a sua volta ad Azzurra.
\end{enumerate}

Per l'invio dei dati invece, cioè l'utente inserisce dei dati che devono essere salvati sul database del backend, ad esempio l'utente inserisce una nuova assenza, il procedimento sarà analogo alla richiesta di dati solo alla fine non verranno ritornati i dati ma l'esito dell'operazione effettuata.
\subsection{Gestione notifiche push}
Nel caso in cui il \gls{plant manager}\ap{[g]} abbia bisogno di mandare una comunicazione a uno o più lavoratori, è stata implementata la possibilità di inviare delle notifiche contenti la comunicazione.
\begin{figure}[h]
	\begin{center}
		\includegraphics[height=6cm, width=14cm]{pushMex.png}
		\caption{Sequence diagram per l'invio di notifiche push}\label{fig:push}
	\end{center}
\end{figure}\\
Nella Figura~\ref{fig:push} viene mostrato come avviene l'invio delle notifiche, di seguito ne vengono descritti i passi:
\begin{enumerate}
	\item Il \gls{plant manager}\ap{[g]} crea il messaggio da inviare attraverso l'interazione con la dashboard di \gls{AWMS};
	\item La dashboard invia al backend il messaggio da inviare e a quali utenti registrati nel sistema, mandare il messaggio, viene perciò mandato oltre al messaggio anche i codici identificativi dei destinatari;
	\item Il backend si connette ad Azzurra.io e gli invia il messaggio e la lista degli utenti a cui deve mandare la notifica. Quindi l'invio della notifica viene delegato a Azzurra.io; 
	\item Azzurra.io controlla sulla sua tabella User Map, quali utenti che devo ricevere il messaggio sono attualmente connessi al socket, oppure invece non lo sono. Si specifica inoltre che vengono considerati utenti connessi o attivi tutti gli utenti che sono connessi e che hanno l’applicazione in foreground. Gli utenti che sono connessi al socket, ma hanno l’applicazione in background vengono trattati come utenti non connessi;
	\item Per gli utenti connessi al socket, Azzurra.io invierà la notifica ai dispositivi connessi in cui verrà visualizzata sotto forma di messaggio da parte di Azzurra;
	\item Nel caso in cui ci siano alcuni utenti non connessi a Azzurra.io tra i destinatari del messaggio, Azzurra.io effettua una richiesta HTTP ad AWMS Backend, specificando gli utenti che non è riuscita a contattare, e il messaggio che avrebbe dovuto recapitare;
	\item Il backend una volta ricevuta la lista degli utenti a cui non è stato possibile mandare la notifica, contatterà attraverso un \gls{api}\ap{[g]} di Firebase, quest'ultimo per richiedere l'invio della notifica agli utenti della lista appena ricevuta. Si specifica che Firebase sarà in grado di farlo solo se i dispositivi dei destinatari si sono sottoscritti al servizio di Firebase per la ricezione di notifiche push;
	\item Firebase ricevuta la lista d'utenti a cui inviare la notifica e il testo del messaggio, invierà la \gls{notifica push}\ap{[g]} ai destinatari.
\end{enumerate}