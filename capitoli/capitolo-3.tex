% !TEX encoding = UTF-8
% !TEX TS-program = pdflatex
% !TEX root = ../tesi.tex
%**************************************************************
\chapter{Archittetura del sistema AWMS}
\label{cap:archittettura del sistema AWMS}
%**************************************************************

\intro{In questo capitolo verranno descritti tutte le componenti dell'architettura \gls{AWMS}\ap{17} e le varie operazioni di comunicazione tra le varie componenti.}\\


\section{Descrizione}
Come scritto precedentemente, dietro all'applicazione mobile c'è tutta un'architettura di sistema che permette la comunicazione tra la piattaforma \gls{AWMS}\ap{18} e l'applicazione mobile con \textbf{Azzurra}.
 
 \begin{figure}[h]
 	\begin{center}
 		\includegraphics[scale=0.28]{AWMSDiagram.png}
 		\caption{Architettura di sistema AWMS}\label{fig:arch}
 	\end{center}
 \end{figure}
La figura precedente illustra come è composta l'architettura, dove ogni componente verrà descritta nelle successive sotto sezioni.
\begin{trivlist}
	\item \subsection{AWMS Dashboard}
	È il pannello di controllo attraverso il quale un project manager può interagire con la piattaforma \gls{AWMS}\ap{18} per poter pianificare il lavoro da svolgere, cioè assegnare un compito alla persona più idonea. Il pannello di controllo è una applicazione web che è stata sviluppata in Angular.
	\begin{figure}[h] 
		\begin{center}
			\includegraphics[scale=0.27]{dashboardAWMS.png}
			\caption{Schermata di AWMS Dashboard}
		\end{center}
	\end{figure}
	 	La dashboard per comunicare con il back-end, utilizza delle \gls{api}\ap{g} che il back-end espone, quindi per una ragione di sicurezza, back-end e l'applicazione web cioè il front-end, comunicano attraverso \gls{api}\ap{2} con in più l'utilizzo del protocollo di comunicazione HTTPS che cripta la comunicazione. Nella Figura~\ref{fig:arch} viene mostrato il caso in cui il front-end utilizza \gls{api}\ap{3} per l'invio di notifiche push, questo perché è previsto che una volta il team leader sceglie il lavoratore più idoneo per un certo lavoro, il lavoratore deve essere avvisato, cosi sarà compito del front-end avvisare il back-end che c'è stata una nuova assegnazione e che questa assegnazione deve essere comunicata al diretto interessato attraverso un notifica sull'applicazione mobile con all'interno \textbf{Azzurra}.
	\item \subsection{AWMS backend}
	Come dice il suo nome, \textbf{AWMS Backend} rappresenta il backend del sistema. \textbf{AWMS Backend} è sviluppato usando lo strumento CakePHP, un framework per lo sviluppo di applicazioni web scritto in PHP. Al suo interno risiede il database che contiene tutte le informazioni sui lavoratori e tra questi quindi, i dati da mostrare nei messaggi di \textbf{Azzurra}come ad esempio il piano di lavoro che ha il lavoratore in uno specifico giorno, qualora ne venga fatta richiesta. Il database utilizza come DBMS PostgreSQL. \\
	Come detto al punto precedente, per comunicare con il backend, esso espone delle \gls{api}\ap{4} per la comunicazione infatti, esiste un \gls{api}\ap{5} per l'invio di notifiche push ma esiste anche un \gls{api}\ap{6}, utilizzata da \textbf{Azzurra.io}, per la richiesta di informazioni sul lavoratore necessarie per completare il flusso di conversazione. Quindi questa \gls{api}\ap{7} permetterà di richiedere dati al backend che li andrà a cercare nel suo database interno che se l'interrogazione al database da esito positivo, ritornerà le informazioni richieste a \textbf{Azzurra.io}. Il backend si trova all'interno della rete interna dell'azienda che ha acquistato la soluzione di AzzurroDigitale, anche \textbf{Azzurra.io} è all'interno della rete, perciò tra queste due componenti avviene attraverso il protocollo di comunicazione HTTP. Il backend ha la possibilità di comunicare direttamente con \textbf{Azzurra.io} quando deve inviare una notifica push e ha necessità di sapere quali utenti sono attivi, cioè hanno una connessione aperta con \textbf{Azzurra.io}. Per gli utenti invece che non hanno una connessione aperte con \textbf{Azzurra.io} e quindi non sono attivi l'invio della notifica verrà fatto utilizzando i servizi offerti da Firebase, la cui comunicazione tra backend e Firebase avviene tramite HTTPS perché Firebase è un servizio esterno.\\
	La gestione l'invio delle notifiche push verrà comunque tratta in modo più dettagliato più avanti nel seguente capitolo.
	\item \subsection{Azzurra.io}
	\textbf{Azzurra.io} è una componente strategica per il funzionamento del bot 
	. \textbf{Azzurra.io} è sviluppata attraverso il framework NestJS. Al suo interno ha due database con DBMS PostgreSQL. Il primo database contiene i flussi di conversazione i quali indicano al bot che sequenza di passi deve fare durante la conversazione con l'utente umano, la loro struttura verrà spiegata in modo dettagliato al capitolo successivo. Il secondo database permette di memorizzare i messaggi fatti tra il bot \textbf{Azzurra} e l'utente umano. La scelta di adottare quest'ultimo database è dettata dalle seguenti motivazioni:
	\begin{itemize}
		\item Per mantenere lo stato della conversazione cioè, se l'utente decide di non andare avanti con la conversazione e di continuarla in un secondo momento, grazie a questo database, in cui viene salvato lo stato della conversazione, potrà continuare la conversazione da dove l'aveva lasciata. Il mantenimento dello stato della conversazione non ha tempo illimitato ma dura al massimo un'ora dopo di che lo stato verrà cancellato;
		\item Per una migliore user experience si è scelto, nel caso in cui ci siano state delle conversazioni in precedenza, di mostrare i messaggi delle conversazioni precedenti, cosi che se l'utente ha bisogno di un’informazione  che ha già chiesto precedentemente ma che si è dimenticato, basta che controlli i messaggi presenti nella chat senza dover richiedere ad \textbf{Azzurra} l'informazione dimenticata.
	\end{itemize}
	La connessione tra l'applicazione mobile e \textbf{Azzurra.io} è possibile grazie ai WebSocket che permettono di aprire una connessione tra i due e di mantenere sempre aggiornati i dati ad esempio la struttura dei flussi di conversazione, qualora venissero aggiornati. Per tenere traccia dei utenti connessi con \textbf{Azzurra.io} tramite l'applicazione mobile, viene utilizzata la mappa chiave-valore, interna ad \textbf{Azzurra.io} denominata User Map, la quale servirà a rispondere alle richieste del backend quando avrà bisogno della lista di utenti attivi per l'invio della notifica push. Come detto all'inizio del punto Azzurro.io è un componente strategico per principalmente due motivi.
	\begin{itemize}
		\item Quando si vuole aggiungere un nuovo flusso conversazionale o modificare un flusso già esistente, se non esistesse \textbf{Azzurra.io}, questi sarebbero salvati nell'applicazione che ne comporterebbe l'aggiornamento dell'applicazione mobile e quindi effettuare una nuova pubblicazione nell'Play Store per i dispositivi Android e nel Apple Store per i dispositivi iOS ad ogni aggiunta o modifica dei flussi. Grazie all'esistenza di \textbf{Azzurra.io} ciò viene evitato perché esiste il database dedicato per la memorizzazione dei flussi conversazionali che se c'è da aggiungere un nuovo flusso basta semplicemente inserirlo all'interno del database, analogamente per la modifica di un flusso. Inoltre, grazie alla connessione tramite WebSocket qualunque modifica o aggiunta viene subito recepita dell'applicazione mobile;
		\item Per evitare che vengano fatte un numero elevato di richieste al backend si è deciso di distribuire le informazioni in diverse componenti della rete, infatti il bot per sapere che flusso conversazionale deve seguire per genere i messaggi per la conversazione con l'utente umano, chiede a \textbf{Azzurra.io} e non al backend. Il backend però verrà contattato quando il bot \textbf{Azzurra} ha bisogno di dati sul lavoratore da mostrare, questa richiesta però sarà fatta inizialmente a \textbf{Azzurra.io} che si prenderà carico di richiedere le informazioni al backend e di ritornarle all'applicazione. Quindi il backend sarà contattato solo dalla dashboard e da \textbf{Azzurra.io} per il caso descritto precedentemente per il processo di autenticazione dell'utente, diminuendo il carico sul backend.
	\end{itemize}
	
	\item\subsection{Applicazione mobile}
	L'ultimo componente dell'architettura e l'applicazione mobile. Essa è sviluppata attraverso il framework Angular2+ e Ionic e al suo interno risiede il bot \textbf{Azzurra}. Oltre al bot \textbf{Azzurra} esisto altre due sezioni, la sezione questionario e la sezione profilo. 
	
	\begin{figure}[h]
		\centering
		\includegraphics[scale=0.118]{queGrey.png}\hfill
		\includegraphics[scale=0.118]{queGreen.png}\hfill
		\includegraphics[scale=0.118]{queRed.png}
		\caption{Sezione Questionario}\label{fig:que}
	\end{figure}
	
	La Figura~\ref{fig:que} mostra la sezione Questionario nei suoi 3 possibili stati. In questa sezione viene richiesto di compilare quotidianamente un questionario in cui vengono poste domande sulla propria salute che, dai dati raccolti per ogni lavoratore l'applicazione cerca di capire se all'interno dell'azienda ci sia pericolo di contagio del virus COVID-19. Nel caso in cui non si è ancora compilato il questionario, viene mostrata una faccina grigia come si può vedere nella prima immagine della Figura~\ref{fig:que}. Se si è compilato il questionario e secondo le risposte date si risulta essere in buona salute, allora l'applicazione mostrerà una faccina verde come si può vedere nella seconda immagine della Figura~\ref{fig:que}. Se si è compilato il questionario e secondo le risposte date si risulta essere a rischio con la propria salute, allora l'applicazione mostrerà una faccina rossa come si può vedere dalla terza immagine della Figura~\ref{fig:que}.
	\\
	\clearpage
	In questa sezione viene richiesto di compilare un questionario dove vengono richiesti se si hanno avuto dei sintomi di malattie come mostra la prima immagine della Figura~\ref{fig:queSlide}. Successivamente viene richiesto se le persone vicino a noi hanno avuto qualche sintomo di malattie come mostrato nella seconda immagine della Figura~\ref{fig:queSlide}. Viene poi richiesto in quelli luoghi si è stati come mostrato nella seconda immagine della Figura~\ref{fig:queSlide}.
	\begin{figure}[h]
		\begin{center}
			\includegraphics[scale=0.12]{que1.png}
			\includegraphics[scale=0.12]{que2.png}
			\includegraphics[scale=0.12]{que3.png}
			\caption{Schede del questionario sulla salute}\label{fig:queSlide}
		\end{center}
	\end{figure}

	Una volta terminato il questionario, l'applicazione elaborare le risposte date e mostrerà l'esito sulla nostra salute. Nel caso in cui l'esito sia positivo verrà mostrata la prima immagine della Figura~\ref{fig:quefinal} invece in caso di esito negativo verrà mostrata la seconda immagine della Figura~\ref{fig:quefinal}.
	\begin{figure}[h]
		\begin{center}
			\includegraphics[scale=0.12]{finalGreen.png}
			\includegraphics[scale=0.12]{finalRed.png}
			\caption{Schede dell'esito del questionario sulla salute}\label{fig:quefinal}
		\end{center}
	\end{figure}\\
	Il risultato viene poi riportato anche nella schermata della sezione Questionario.
	\\
	Nella sezione Profilo invece, vengono mostrati i Karma points che sono stati raccolti durante la compilazione del questionario, punti che al momento non danno nessun particolare beneficio ma, in futuro è previsto l'implementazione di una qualche ricompensa. Vengono mostrate le proprie informazioni personali cliccando il tasto Informazioni personali come mostrato in Figura~\ref{fig:profile}, e possibile cambiare la password d'accesso cliccando il bottone Gestione password. Cliccando il bottone Istruzione di utilizzo mostrato sempre nella Figura~\ref{fig:profile} e possibile accedere a una breve guida su come utilizzare l'applicazione. Nel bottone Normativa privacy è possibile visionare la normativa sulla tutela della privacy GDPR mentre nel bottone Titolare trattamento viene indicato da chi vengono trattati i dati inseriti.
	\begin{figure}[h]
		\begin{center}
			\includegraphics[scale=0.11]{profile.png}
			\caption{Sezione Profilo}\label{fig:profile}
			\includegraphics[scale=0.11]{chatAzzurra.png}
			\caption{Sezione Chat bot Azzurra}\label{fig:Azzurra}
		\end{center}
	\end{figure}\\
	Nella sezione \textbf{Azzurra}, è presente la chat bot con \textbf{Azzurra} che attraverso il proprio flow engine, riesce a comprendere i flussi conversazionali ricevuti in input da \textbf{Azzurra.io}. Grazie a ciò il bot \textbf{Azzurra} sa quali risposte e domande fare all'utente umano. Nel capitolo successivo verrà spiegato in modo dettagliato il funzionamento del Flow engine di \textbf{Azzurra}. Come detto precedentemente la comunicazione con \textbf{Azzurra.io} avviene attraverso WebSocket che permette di tenere aggiornati i flussi conversazionali ricevuti da \textbf{Azzurra.io} nel caso in cui subiscano modifiche.	
	
\end{trivlist}
\section{Operazioni}
Nella seguente sezione verranno descritte le principali operazioni tra le varie componenti dell'architettura.
\subsection{Creazione di una connessione attreverso WebSocket}
Come spiegato in precedenza, la comunicazione tra l'applicazione mobile e \textbf{Azzurra.io} avviene attraverso l'utilizzo di WebSocket. Grazie a ciò si ha un canale di comunicazione a due vie cioè, sia l'applicazione mobile e sia \textbf{Azzurra.io } possono inviare dati o richieste inoltre, grazie a questo tipo di comunicazione, le modifiche ai flussi conversazionali già esistenti o l'aggiunta di nuovi flussi, verranno comunicate all'applicazione mobile in tempo reale, aggiornando perciò i dati posseduti dell'applicazione. Infine, utilizzando una connessione tramite WebSocket, risulta essere più efficiente e performante rispetto al pooling perchè il server non viene continuamente contatto da inutili richieste.
\begin{figure}[h]
	\begin{center}
		\includegraphics[scale=0.8]{Connection-WebSocket.PNG}
		\caption{Sequence diagram per la creazione di una connessione attraverso WebSocket}\label{fig:websocket}
	\end{center}
\end{figure}

Nella Figura~\ref{fig:websocket} viene mostrato come avviene la creazione di una connessione tra l'applicazione mobile e \textbf{Azzurra.io}, i passi perciò sono:
\begin{enumerate}
	\item All'inizio, l'applicazione mobile viene aperta dall'utente, essa cercherà da subito di mettersi in contatto con \textbf{Azzurra.io} creando una connessione;
	\item Per avviare una connessione WebSocket, viene inviata una richiesta HTTPS a \textbf{Azzurra.io}(server). Tale richiesta HTTPS ha la particolarità che negli headers dell’intestazione viene specificata un'operazione di tipo Upgrade che indica che l'applicazione mobile (client) vuole aggiornare la connessione ad un protocollo diverso, in questo caso a WebSocket. Questo tipo di operazione prende il nome di WebSocket handshake request.
	\begin{lstlisting}
GET /mychat HTTPS/1.1
Host: server.AzzurraIo.com
Upgrade: websocket	
Connection: Upgrade		
Sec-WebSocket-Key: 32ndfsMjnQiZXBijAfOiPni==
Sec-WebSocket-Protocol: chat		
Sec-WebSocket-Version: 13		
Origin: http://AzzurraIo.com
	\end{lstlisting}
	Il codice soprastante rappresenta un esempio di WebSocket handshake request inviata dal client al server. Il client inserisce una stringa casuale codifica in base64 nel campo Sec-WebSocket-Key alla quelle viene poi aggiunta una stringa fissa.
	\item Se il server, in questo caso \textbf{Azzurra.io} supporta la connessione tramite WebSocket allora rispondere mettendo nel campo Sec-WebSocket-Accept la risposta cioè, l'hash della stringa contenuta in Sec-WebSocket-Key utilizzando la funzione di hashing SHA-1. Infine, viene tutto codificato in base64. Una volta arrivata la risposta al client, esso controllerà se la risposta contiene la stringa corretta. Tutte queste operazioni hanno lo scopo di evitare di aprire più connessioni multiple ma non da nessuna garanzia di autenticazione, tale garanzia e data dall'utilizzo del HTTPS.
	Nel seguente codice viene riportato un esempio di risposta da parte del server.
	\begin{lstlisting}
HTTPS/1.1 101 Switching Protocols
Upgrade: websocket
Connection: Upgrade
Sec-WebSocket-Accept: fPmrc0slUIUYIuyY2HaGWk=
Sec-WebSocket-Protocol: chat
	\end{lstlisting}
\end{enumerate}

\subsection{Recupero di un flusso conversazionale}
\begin{figure}[h]
	\begin{center}
		\includegraphics[scale=0.75]{recovery.png}
		\caption{Sequence diagram per il recupero di un flusso conversazionale}\label{fig:recovery}
	\end{center}
\end{figure}
Il bot \textbf{Azzurra} per poter funzionare ha bisogno di almeno un flusso conversazionale che grazie alla propria struttura, permette al flow engine di \textbf{Azzurra} di comprendere il flusso e capire quali messaggi deve far visualizzare ad \textbf{Azzurra} nella chat con l'utente umano. I flussi si trovano nel database dedicato di \textbf{Azzurra.io}. Quando viene richiesto di fare un’operazione o si inizia per la prima volta un'interazione con \textbf{Azzurra}, essa per sapere cosa fare ha bisogno di uno specifico flusso di conversazione, nel caso in cui sia la prima interazione con l'utente, richiedere il cosiddetto MainFlow dove vengono riportate quali funzionalità \textbf{Azzurra} può offrire. Se invece si è nel caso in cui l'utente richiede una specifica funzionalità ad esempio richiedere la visualizzazione del piano di lavoro, \textbf{Azzurra} dovrà richiedere il flow dedicato alla specifica funzionalità.
Come mostrato nella Figura~\ref{fig:recovery} si hanno i seguenti passi:
\begin{enumerate}
\item L'utente interagisce con il bot \textbf{Azzurra} e richiede una funzionalità oppure l'utente interagisce con \textbf{Azzurra} per la prima volta;
\item Il bot \textbf{Azzurra} tramite una connessione aperta precedentemente chiede a \textbf{Azzurra.io} il corretto flow per poter soddisfare le richieste dell'utente. Si sottolinea che ogni flow ha un codice identificativo che lo identifica e \textbf{Azzurra} sa sempre qual'è il codice identificativo del flusso di cui ha bisogno;
\item \textbf{Azzurra.io} cerca nel proprio database se contiene il flow richiesto;
\item Se la ricerca da esito positivo allora \textbf{Azzurra.io} ritornerà il flusso che verrà eseguito dal flow engine di \textbf{Azzurra} la quale proseguirà con la conversazione. Se invece non lo trova la conversazione si interrompe mostrando nella chat un messaggio di errore.
\end{enumerate}

\subsection{Richiesta e invio di dati}
Durante l'esecuzione di una conversazione è molto probabile che \textbf{Azzurra} abbia bisogno di far visualizzare delle informazioni richieste dall'utente ad esempio il suo orario di lavoro, queste informazioni però non sono salvate ne nell'applicazione mobile né in \textbf{Azzurra.io} ma nel backend.
\begin{figure}[h]
	\begin{center}
		\includegraphics[height=5cm, width=13cm]{request.png}
		\caption{Sequence diagram per il recupero dei dati sul lavoratore}\label{fig:request}
	\end{center}
\end{figure}
La Figura~\ref{fig:request} mostra come \textbf{Azzurra} ottiene i dati richiesti:
\begin{enumerate}
	\item L'utente chiede una qualche operazione ad \textbf{Azzurra} che necessita contattare il backend per ottenere i dati che l'utente vuole;
	\item L'applicazione chiede quindi i dati necessari a \textbf{Azzurra.io} che si prende carico della richiesta;
	\item \textbf{Azzurra.io} contatta attraverso una richiesta HTTP, per richiedere i dati richiesti da Azzurra;
	\item Se la richiesta va a buon fine il backend ritornerà i dati ad \textbf{Azzurra.io} che li ritornerà a sua volta ad \textbf{Azzurra}.
\end{enumerate}

Per l'invio dei dati invece, ciò l'utente inserisce dei dati che devono essere salvati sul database del backend, ad esempio l'utente inserisce una nuova assenza, il procedimento sarà analogo alla richiesta di dati solo alla fine non verranno ritornati i dati ma l'esito dell'operazione effettuata.
\subsection{Gestione notifiche push}
Nel caso in cui il project manager abbia bisogno di mandare una comunicazione a uno o più lavoratori, è stata implementata la possibilità di inviare delle notifiche contenti la comunicazione.
\begin{figure}[h]
	\begin{center}
		\includegraphics[height=6cm, width=14cm]{pushMex.png}
		\caption{Sequence diagram per l'invio di notifiche push}\label{fig:push}
	\end{center}
\end{figure}\\
Nella Figura~\ref{fig:push} viene mostrato come avviene l'invio delle notifiche, di seguito ne vengono descritti i passi:
\begin{enumerate}
	\item Il project manager crea il messaggio da inviare attraverso l'interazione con la dashboard di AWMS;
	\item La dashboard invia al backend il messaggio da inviare e a quali utenti registrati nel sistema, mandare il messaggio, viene percio mandato oltre al messaggio anche i codici identificativi dei destinatari;
	\item Il backend si connette ad \textbf{Azzurra.io} e gli invia il messaggio e la lista degli utenti a cui deve mandare la notifica. Quindi l'invio della notifica viene delegato a \textbf{Azzurra.io}; 
	\item \textbf{Azzurra.io} controlla sulla sua tabella User Map, quali utenti che devo ricevere il messaggio sono attualmente connessi al socket, oppure invece non lo sono. Si specifica inoltre che vengono considerati utenti connessi o attivi tutti gli utenti che sono connessi e che hanno l’applicazione in foreground. Gli utenti che sono connessi al socket, ma hanno l’applicazione in background vengono trattati come utenti non connessi;
	\item Per gli utenti connessi al socket, \textbf{Azzurra.io} invierà la notifica ai dispositivi connessi in cui verrà visualizzata sotto forma di messaggio da parte di \textbf{Azzurra};
	\item Nel caso in cui ci siano alcuni utenti non connessi a \textbf{Azzurra.io} tra i destinatari del messaggio, \textbf{Azzurra.io} effettua una richiesta HTTP ad \textbf{AWMS Backend}, specificando gli utenti che non è riuscita a contattare, e il messaggio che avrebbe dovuto recapitare;
	\item Il backend una volta ricevuta la lista degli utenti a cui non è stato possibile mandare la notifica, contatterà attraverso un \gls{api}\ap{8} di Firebase, quest'ultimo per richiedere l'invio della notifica agli utenti della lista appena ricevuta. Si specifica che Firebase sarà in grado di farlo solo se i dispositivi dei destinatari si sono sottoscritti al servizio di Firebase per la ricezione di notifiche push;
	\item Firebase ricevuta la lista d'utenti a cui inviare la notifica e il testo del messaggio, invierà la notifica push ai destinatari.
\end{enumerate}